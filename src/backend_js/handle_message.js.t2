;;; ntpy_js
;;- handle message
if(msg['cmd'] == "execute")
{
	; check message format for execute
	; add or replace section to database
	; notify front that kernel is running section
	; retangle all sections
	; add or replace parent section to running sections
	; increase task id
}

;; check message format for execute
const msg_data = msg["data"];

;; variables
var sections = {};

;; add or replace section to database
const name = msg_data['name'];
const lines = msg_data["lines"];
sections[name] = lines;

;; variables
var tangled = {};

;; functions
function tangle_rec(name, sections, tangled, parent_section, blacklist, prefix)
{
  ; return if name in blacklist
  ; add name to blacklist
  if(!(name in sections))
  {
    return [];
  }

  if(name in tangled)
  {
    return tangled[name];
  }

  var lines = [];
  for(var line of sections[name])
  {
    ; if line is literate reference recurse
    ; otherwise just add line to list
  }

  tangled[name] = lines;
  ; pop blacklist
  return lines;
}

;; retangle all sections
tangled = {};
; clear retangling all

for(const section_name in sections)
{
  blacklist = [];
  tangle_rec(section_name, sections, tangled, parent_section, blacklist, "");
}

;; if line is literate reference recurse
if(/\s*;[^;].*/.test(line))
{
  ; extract reference name
  ; recurse and add lines from reference
}

;; otherwise just add line to list
else
{
  lines.push(line);
}

;; extract reference name
const matches = /(\s*);([^;].*)/;
const new_prefix = matches[1];
const ref_name = matches[2].trim();
; add parent to reference

;; add name to blacklist
blacklist.push(name);

;; pop blacklist
blacklist.pop();

;; return if name in blacklist
if(blacklist.indexOf(name) != -1)
{
  return [];
}

;; recurse and add lines from reference
const ref_lines = tangle_rec(ref_name, sections, tangled, parent_section, blacklist, prefix + new_prefix);
if(ref_lines.length > 0)
{
  for(const ref_line of ref_lines)
  {
    lines.push(prefix + new_prefix + ref_line);
  }
}

;; variables
var parent_section = {};

;; clear retangling all
parent_section = {};

;; add parent to reference
if(!(ref_name in parent_section))
{
  parent_section[ref_name] = [];
}

if(!(name in parent_section[ref_name]))
{
  parent_section[ref_name].push(name);
}

;; variables
var pending_sections = [];

;; add or replace parent section to running sections
if(msg_data['execute'])
{
  var has_loop_parent = false;
  ; check if any parent is loop
  if(!has_loop_parent)
  {
    pending_sections.push(name);
  }
}

;; check if any parent is loop
var open = [name];
var closed = new Set([]);
closed.add(name);
while(open.length > 0)
{
  var current = open.pop();
  if(current == "loop")
  {
    has_loop_parent = true;
    break;
  }

  if(current in parent_section)
  {
    for(const parent in parent_section[current])
    {
      if(!closed.has(parent))
      {
        open.push(parent);
        closed.add(current);
      }
    }
  }
}
